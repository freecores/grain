

Using the Grain IP
==================

0. WHATS IN THERE:
------------------

copying.txt                           the LGPL license
DOC/
    using.txt                         this file
SRC/
    TCL/
        01_testbenches.tcl            Aldec Riviera simulation script
    VHDL/
        TEST_SIM/
            tb_grain.vhd              Testbench for Grain-1
            tb_grain128.vhd           Testbench for Grain-128
        TEST_SYNTH/
            hw1_grain.vhd             \
            hw2_grain.vhd
            hw3_grain.vhd              
            hw4_grain.vhd              These are misc files for
            hw1_grain128.vhd           synthesis tests
            hw2_grain128.vhd                        
            hw3_grain128.vhd                        
            hw4_grain128.vhd          /
        grain.vhd                     Grain-1 top file
        grain_datapath_fast.vhd       Grain-1 fast datapath
	grain_datapath_slow.vhd       Grain-1 slow datapath	
	grain128.vhd                  Grain-128 top file
	grain128_datapath_fast.vhd    Grain-128 fast datapath
	grain128_datapath_slow.vhd    Grain-128 slow datapath
	
            
  


1. SETUP:
---------

To use the Grain IP, first instantiate the VHDL entity in your design:


	grain: entity work.grain
	generic map ( 
		DEBUG => false,
		FAST  => false
	)
	port map (
		CLK_I    => clk,
		CLKEN_I  => clken,
		ARESET_I => areset,
	
		KEY_I  => key_in,
		IV_I   => iv_in,
		INIT_I => init,
		
		KEYSTREAM_O       => keystream,
		KEYSTREAM_VALID_O => keystream_valid
	);
	

Notice that this entity requires a clock, an asynchronous reset and an 
(optional) clock enable.

You also need to add the grain implementation files to your project:
  - "grain.vhd" 
  - "grain_datapath_fast.vhd"
  - "grain_datapath_slow.vhd"

Notice that only one of the datapath files will be used.


2. INITIALIZATION:
------------------

To start the stream cipher, you must supply it with a key and an IV. 
In the case of Grain-1, these are 80 and 64 bits respectively.

The key and IV are feed to the cipher one bit each clock, after that the
[INIT_I] signal has been asserted for one clock cycle:



CLK_I      /--\__/--\__/--\__/--\__/--\__/--\__/--\__/--\__
CLKEN_I    /-----\_____/-----\_____/-----\_____/-----\_____

INIT_I     /------\________________________________________

KEY_I      --------< K0      >< K1       >< K2     ....
IV_I       --------< IV0     >< IV1      >< IV2    ....

(here we assume that clock is enabled every other cycle)


After 64 (enabled) clock cycles, the IV has been fed to the cipher.
16 clock cycles later, the key has also been fed to the cipher. 
At this point, the user should simply wait for the output.



3. OUTPUT:
----------

At some point after initialization, the keystream will start to appear
on the [KEYSTREAM_O] output at the same time the signal
[KEYSTREAM_VALID_O] will be asserted. 

This output sequence works as following:


CLK_I              /--\__/--\__/--\__/--\_...._/--\__/--\__/--\__/--\__
CLKEN_I            /-----\_____/-----\____...._/-----\_____/-----\_____

INIT_I             /------\_______________...._________________________


KEYSTREAM_O        ##################################< KS0       >< KS1 ...
KEYSTREAM_VALID_O  ###################>___...._______/-------------- ...

The module will generate one bit of key stream for each enabled clock cycle.
(here we assume every other clock is enabled)


4. RE-INITIALIZATION:
---------------------

To change the key and/or IV, simply repeat the initialization procedure.

Beware however that the keystream from the old key/IV pair will still
be produced up to one clock cycle after [INIT_I] have been re-asserted.

Notice also that you are not allowed to re-start the initialization
sequence before it has finished. The initialization sequence is finished
when [KEYSTREAM_VALID_O] is asserted.


5. GRAIN-128:
-------------

The grain128 IP works in the same way. The only difference is that key size 
is increased to 128 bits and IV size is increased to 96 bits.




6. SIMULATION:
--------------

Two testbenches are provided, one for Grain-1 and one for Grain-128. 
They both uses testvectors from the original Grain papers.

A TCL script to compile and run each testbench from Aldec Riviera can 
be found under SRC/TCL. Notice that the this script will test both 
the slow and the fast datapaths.
